# Dokumentation - Hermes

## Projekttagebuch

| Aufgabe | Zuständiger | Datum |
|-|-|-|
Erster Entwurf von ERM/RM | Jannik & Noah | 30. April |
ERM/RM überarbeitet | Jannik & Noah | 2. Mai |
Klassendiagramm erstellt | Jannik & Noah | 2. Mai |
Entwurf von REST-API (Endpunkte) | Jannik & Noah | 5. Mai |
REST-API Endpunkte, Klassendiagramm und ERM/RM überarbeitet | Jannik & Noah | 6. Mai |
Logo erstellt | Jannik & Noah | 6. Mai
Klassendiagramm und ERM/RM überarbeitet | Jannik & Noah | 7. Mai |
Klassen hinzugefügt zu Flutter | Jannik | 8. Mai |
BottomNavBar designed und zum Projekt hinzugefügt | Jannik | 8. Mai |
Map zur HomePage hinzugefügt (OpenStreetMap) | Jannik | 9. Mai |
Collection Page (Sammelkarten-Seite) hinzugefügt | Noah | 9. Mai |
Location Permition hinzugefügt | Jannik | 9. Mai |
Funktion zum Zoomen zur aktuellen Position hinzugefügt | Jannik | 17. Mai |
Erste Version von Tracking hinzugefügt | Jannik | 17. Mai |
Login- und Settingspage hinzugefügt | Jannik | 17. Mai |
Schriftart geändert | Noah | 19. Mai |
ERM/RM überarbeitet | Jannik & Noah | 21. Mai |
BottomNavBar responsive gemacht | Jannik | 21. Mai |
Problem beim Wechseln der Seiten behoben, da noch auf Widgets in der alten Page zugegriffen wurde | Jannik | 21. Mai |
BottomNavBar verändert | Jannik | 21. Mai |
Appbar zur Einstellungsseite hinzugefügt | Jannik | 21. Mai | 
Backend und Yaml hinzugefügt | Jannik | 21. Mai |
Erfolgcircle hinzugefügt (kleinen Erfolge in der Einstellungsseite) | Jannik | 21. Mai |
Endpunkte ausprogrammiert - Bestenliste und UpdateUser | Noah | 21. Mai |
BenutzerController fertiggestellt | Noah | 23. Mai |
Background-Tracking hinzugefügt | Jannik | 28. Mai |
Tracking wird beim Wechseln der Seiten fortgesetzt | Jannik | 28. Mai |
Login Page responsive gemacht | Jannik | 28. Mai |
BackgroundTracking gefixed | Jannik | 29. Mai |
Login- und Regestrierungsfunktion hinzugefügt | Jannik | 29. Mai |
Chaching hinzugefügt bei Login und Register (shared_preferences) | Jannik | 29. Mai |
SideBar in Einstellungsseite hinzugefügt | Jannik | 29. Mai |
Alle Endpunkte prototypmäßig ausprogrammiert | Noah | 30. Mai |
Daten in Einstellungsseite laden und anzeigen | Jannik | 30. Mai |
Endpunkte umbenannt und DB verbessert | Noah | 1. Juni |
add_erfolg Endpunkt aktualisiert | Noah | 1. Juni |
Freigeschaltete und nicht Freigeschaltete Erfolge zur Einstellungsseite hinzugefügt | Jannik | 1. Juni |
Gelaufene Distand und Berge/Ziele in DB speichern (also wenn man seine Wanderung trackt und dann beendet wird die Distanz in die DB geschrieben) | Jannik | 1. Juni |
Erfolge in der Einstellungsseite responsive gemacht | Jannik | 2. Juni |
Passwort aus dem Cache entfernt | Jannik | 2. Juni |
Bestenliste_Controller fertig gemacht (10 Plätze und den eingeloggten User, wenn er nicht unter den Top 10 ist) | Noah | 4. Juni |
NFC-Reader (Klasse) hinzugefügt | Jannik | 4. Juni |
Hinzufügen Button zur Sammelkarten-Seite hinzugefügt | Noah | 4. Juni |
NFC-Reader in Sammelkarten-Seite integriert | Jannik | 4. Juni |
Hinzufügen Button in Sammelkarten-Seite geändert | Noah | 4. Juni |
Login- und Regestrierungsfunktion in UserManager integriert | Jannik | 4. Juni |
LoadUserData, Erfolge, ... in UserManager integriert | Jannik | 4. Juni |
System erkennt wenn neuer Erfolg freigeschaltet wurde und zeigt diesen an (Settingsseite) | Jannik | 4. Juni |
Globale Variable ServerIP hinzugefügt (Connection via Tailscale) | Jannik | 5. Juni |
Beim Hinzufügen von Sammelkarten wird nun geprüft ob man sich in der Nähe vom Ziel befindet (500 m) | Jannik | 5. Juni |
NFC-Reader Funktion von Klasse in Sammelkarten-Seite integriert | Noah | 5. Juni |
ValidierungsManager in Sammelkarten-Seite integriert (Hinzufügen von Zielen/Sammelkarten) | Noah | 5. Juni |
Erfolg-Abschnitt in Settings-Seite responsive gemacht | Jannik | 5. Juni |
Login Page responsive gemacht | Jannik | 6. Juni |
App prüft bevor dem Starten ob der Server erreichbar ist | Jannik | 6. Juni |
Fixed Bug (CircularProgressIndicator ging nicht weg) | Jannik | 6. Juni |
Leaderboard-Seite hinzugefügt | Jannik | 6. Juni |
Logging zu UserManger und ValidierungsManager hinzugefügt | Jannik | 6. Juni |
Logging zu TrackingService hinzugefügt | Jannik | 6. Juni |
Logging zu Main, ServerOffline und Settings hinzugefügt | Jannik | 6. Juni |
Scrollbar zur Sammelkarten-Seite hinzugefügt | Noah | 6. Juni |
Änderungen am Backend | Noah | 9. Juni |
Sammelkarten-Seite fertig gemacht (coole Effekte, Schwirigkeit und Bilder) | Noah | 9. Juni |
Erster Entwurf von UnitTests | Jannik | 9. Juni |
Filter-Funktion in Sammelkarten-Seite hinzugefügt | Noah | 9. Juni |
Fixed Bug (Platzierung im Leaderboard) | Jannik | 9. Juni |
Logging zu Sammelkarten-Seite hinzugefügt | Jannik | 13. Juni |
Logging zu ErfolgController hinzugefügt | Jannik | 13. Juni |
Logging zu BestenlisteController hinzugefügt | Jannik | 13. Juni |
Logging zu BenutzerController hinzugefügt | Jannik | 13. Juni |
UnitTests für UserManager, ValidierungsManager (KI) | Jannik | 13. Juni |
Datenbank Rolle (app) hinzugefügt | Jannik | 14. Juni |
An Doku gearbeitet | Jannik | 14. Juni |
An Doku gearbeitet | Jannik | 15. Juni |

 
## Projektplanung
Keine Ahnung was hier her kommt

## Umsetzungsdetails

### Softwarevoraussetzungen (Versionen)
- flutter_map: ^6.0.0
- flutter_svg: ^2.0.0
- latlong2: ^0.9.0
- pdf : ^3.10.6
- path_provider: ^2.1.2
- flutter_map: ^6.0.0    
- flutter_svg: ^2.0.0
- latlong2: ^0.9.0
- pdf: ^3.10.6
- path_provider: ^2.1.2
- cupertino_icons: ^1.0.8
- google_nav_bar: ^5.0.6
- geolocator: ^10.0.0
- flutter_map_location_marker: any
- location: ^5.0.0
- http: ^1.2.0
- shared_preferences: ^2.2.2
- flutter_nfc_kit: ^3.3.1
- logger: ^2.0.2

### Umsetzung

#### Tracking

Das Tracking bzw. die Karte wurde mit OpenStreetMap (`flutter_map`) umgesetzt. Zudem wurde die `flutter_map_location_marker`-Bibliothek verwendet, um den aktuellen Standort des Benutzers anzuzeigen. Die Karte kann gezoomt und verschoben werden, und es gibt eine Funktion, die den Benutzer auf seine aktuelle Position zentriert. Das `location`-Paket wird verwendet, um die Standortberechtigungen zu verwalten und den aktuellen Standort des Benutzers zu erhalten. Die Strecke die man gelaufen ist, wird dann mithilfe einer Polyline auf der Karte angezeigt.

Das wär z.B. die Funktion um das Tracking zu starten:
```dart
void startTracking() {
    logger.i('Tracking gestartet');
    trackedRoute.clear();
    totalDistance = 0.0;
    accumulatedDuration = Duration.zero;
    startTime = DateTime.now();
    isTracking = true;

    _locationSubscription = location.onLocationChanged.listen((loc) {
      final LatLng newPoint = LatLng(loc.latitude!, loc.longitude!);
      if (trackedRoute.isNotEmpty) {
        totalDistance += _distanceCalculator(trackedRoute.last, newPoint);
      }
      trackedRoute.add(newPoint);
      onLocationUpdated?.call();
    });
  }
```

Dies ist die Funktion, die verwendet wird um die aktuelle Position zu zoomen:
```dart
Future<void> _zoomToCurrentLocation() async {
    final hasPermission = await _location.hasPermission();
    if (hasPermission == PermissionStatus.denied) {
      await _location.requestPermission();
      logger.i('Berechtigung zum Orten nicht erteilt... Erlaubnis wird angefragt');
    }

    final serviceEnabled = await _location.serviceEnabled();
    if (!serviceEnabled) {
      await _location.requestService();
    }

    final currentLocation = await _location.getLocation();
    if (mounted) {
      _mapController.move(
        LatLng(currentLocation.latitude!, currentLocation.longitude!),
        20.0, 
      );
    }
    logger.i('Zum aktuellen Standort gezoomt');
  }
```

Das ist die Funktion, die aufgerufen wird wenn der Button auf der HomePage gedrückt wird und je nach Status des Trackings wird es dann entweder gestartet, fortsetzt oder gestoppt:
```dart
void _toggleTracking() {
    if (trackingService.isTracking) {
      logger.i('Tracking Stop wurde gedrückt');
      trackingService.stopTracking();
    } else {
      if (trackingService.startTime != null) {
        logger.i('Tracking Fortsetzung wurde gedrückt');
        trackingService.resumeTracking();
      } else {
        logger.i('Tracking Start wurde gedrückt');
        trackingService.startTracking();
      }
    }
    setState(() {});
  }
```

#### Sammelkarten
Noah

#### Leaderboard
Das Leaderboard wurde mithilfe einer PageView erstellt, welche das Wechseln zwischen den einzelnen Kategorieren ermöglicht. Zudem gibt es eine Klasse `leaderboardsingle`, welche das jeweilige Leaderboard je nach Kategorie anzeigt. Die ersten drei Plätze sind mit Gold, Silber und Bronze gekennzeichnet und der eingeloggte User mit Grün (Funktion `getMedalColor`). Befindet er sich nicht unter den Top 10, wird noch eine Platzierung unterhalb der Top 10 angezeigt.

Hier holt man z.B. die Daten für das Leaderboard:
```dart
Future<List<Map<String, dynamic>>> loadleaderboard() async {
    final prefs = await SharedPreferences.getInstance();
    int? id = prefs.getInt('id');
    final url = Uri.parse('http://$serverIP:8080/user/bestenliste?userID=$id&filterDB=$category');
    final response = await http.get(url);
    final result = json.decode(response.body);
    print(result);

    return List<Map<String, dynamic>>.from(result);
  }
```

Funktion für die Farben der Platzierungen:
```dart
Future<Color> getMedalColor(int place, Map<String, dynamic> entry) async {
    int? userID = await getUserId();
    switch (place) {
      case 1:
        return const Color(0xFFFFD700); // Gold
      case 2:
        return const Color(0xFFC0C0C0); // Silber
      case 3:
        return const Color(0xFFCD7F32); // Bronze
      case _ when entry['ID'] == userID:
        return const Color(0xFF4A742F); // Aktueller User hervorheben
      default:
        return Colors.white;
    }
  }
```

#### Login/Registrierung
Das Login bzw. die Registierung wurden hauptsächlich einfach mit HTTP-Requests umgesetzt. Um sich nicht jedes Mal neu anmelden zu müssen, wurde der Benutzername, ID und ein Bool `isLoggedIn` mithilfe von `shared_preferences` gecached. Beim Start der App wird dann geprüft, ob `isLoggedIn` true ist und je nach dem wird dann das Login übersrprungen und direkt zur HomePage weitergeleitet.

Login-Funktion in `UserManager`:
```dart
static Future<bool> Login(BuildContext? context, String username, String password, {http.Client? client,}) async {
    client ??= http.Client(); // Normalfall, das andere ist nur für die Unit-Tests
    final url = Uri.parse('http://$serverIP:8080/user/login?benutzername=$username&passwort=$password');
    final response = await client.get(url);
    final result = json.decode(response.body);
    if (result == -1){
      logger.w('Login fehlgeschlagen!');
      if (context != null){
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: Text('Login fehlgeschlagen'),
            content: Text('Benutzername oder Passwort ist falsch.'),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: Text('OK'),
              ),
            ],
          ),
        );
      }
      return false;
    }

    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt('id', result); // Cachen der Daten, damit man sich nicht jedes Mal neu anmelden muss
    await prefs.setString('username', username);
    await prefs.setBool('isLoggedIn', true);

    logger.i('Login erfolgreich');
    return true;
  }
```

#### Einstellungen
Die Einstellungsseite ist im Prinzip die Übersicht über die Stats und Erfolge eines Users. Sie biete auch die Möglichkeit sich wieder abzumelden und eine Funktion um den User zu bearbeiten wäre auch vorgesehen, aber noch nicht umgesetzt. Die Seite holt sich die Userdaten über den `UserManager`, genauer gesagt über die Funktion `loadUserData` und zeigt diese an. Zudem werden die Erfolge angezeigt, die ein User freigeschaltet hat und die es noch gibt. Zuerst werden dafür die Erfolge des Users mit der Funktion `loadUserErfolge` und anschließend der Funktion `loadAllErfolge` mitgeben, welche die noch fehlenden Erfolge ermittelt. Anschließend werden sie dann angezeigt, je nach Bildschirmgröße, werden verschieden viele in einer Reihe angezeigt. Zusätzlich wird immer wenn man die Einstellungsseite öffnet, geprüft, ob neue Erfolge freigeschaltet wurden mithilfe der Funktion `checkErfolge`. Diese zeigt dann auch kurz einen Dialog, wenn man einen neuen Erfolg fregeschaltet hat.

Die Funktion `loadUserData`:
```dart
static Future<Map<String, dynamic>> loadUserData({http.Client? client, }) async {
    client ??= http.Client();
    final prefs = await SharedPreferences.getInstance();
    int? id = prefs.getInt('id');
    final url = Uri.parse('http://$serverIP:8080/user/datenabfrage?user_id=$id');
    final response = await client.get(url);
    if (response.statusCode == 401){
      logger.w('User not found');
      throw Exception('User not found');
    }
    final result = json.decode(response.body);
    final urlBerge = Uri.parse('http://$serverIP:8080/erfolg/erreichteziele?userID=$id');
    final responseBerge = await client.get(urlBerge);
    if (responseBerge.statusCode != 200){
      logger.w('Ungülte Eingabe/Fehler bei Ziel-Abfrage');
      throw Exception('Ungültige Eingabe/Fehler bei Ziel-Abfrage');
    }
    final resultBerge = json.decode(responseBerge.body);
    logger.i('Benutzerdaten erfolgreich geladen');
    return {
      'username': prefs.getString('username') ?? 'Unbekannt',
      'kmgelaufen': result['kmgelaufen'] ?? 0,
      'hoehenmeter': result['hoehenmeter'] ?? 0,
      'berge': resultBerge.length ?? 0,
    };
  }
```

Die Funktion `loadUserErfolge`:
```dart
static Future<List<Erfolg>> loadUserErfolge({http.Client? client, }) async {
    client ??= http.Client();
    final prefs = await SharedPreferences.getInstance();
    int? id = prefs.getInt('id');
    final url = Uri.parse('http://$serverIP:8080/erfolg/get_erfolge?userID=$id');
    final response = await client.get(url);
    if (response.statusCode != 200){
      logger.w('Fehler beim Laden der Erfolge');
      throw Exception('Fehler beim Laden der Erfolge!');
    }
    final result = json.decode(response.body);
    print(result);
    logger.i('Erfolge erfolgreich geladen');
    return (result as List)
      .map((e) => Erfolg.fromJson(e as Map<String, dynamic>))
      .toList();
  }
```

Die Funktion `checkErfolge`:
```dart
static Future<void> checkErfolge(BuildContext? context, {http.Client? client, }) async {
    client ??= http.Client();
    final prefs = await SharedPreferences.getInstance();
    int? id = prefs.getInt('id');
    final url = Uri.parse('http://$serverIP:8080/erfolg/check_erfolge?userID=$id');
    final response = await client.get(url);
    if (response.statusCode != 200){
      logger.w('Fehler bei der Abfrage, ob ein neuer Erfolg freigeschaltet wurde');
      throw Exception('Fehler bei der Abfrage, ob ein neuer Erfolg freigeschaltet wurde');
    }
    final result = json.decode(response.body);
    
    if (result){
      logger.i('Erfolge erfolgreich überprüft');
      if (context != null){
        showDialog(
          context: context,
          builder: (context) => AlertDialog(
            title: Text('Neuer Erfolg!'),
            content: Text('Neuer Erfolg freischalten'),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: Text('OK'),
              ),
            ],
          ),
        );
      }  
    }
  }
```

### Probleme und Lösungen

#### Tracking
Also das größte Problem hierbei war, dass das Tracking auch im Hintergrund weiterlaufen soll, wenn der Benutzer die App verlässt oder auf eine ander Page wechselt. Zuerst wurde das Ganze mit `background_locator_2` umgesetzt, aber dabei hat es jedoch sehr viele Probleme mit Versionen usw. gegeben, weshalb wir uns dann für das `location`-Paket entschieden haben, welches bis zum jeztigen Zeitpunkt keine Probleme gemacht hat.

#### Leaderboard
Das Problem hierbei war, dass wenn sich der User nicht unter den Top 10 befand, dass man nicht im Frontend nicht wusste, welche Platzierung er hat. Deshalb hat Noah noch ein zusätzliches Attribut hinzugefügt, welches die Platzierung des jeweiligen Users angibt und somit war das Problem auch wieder behoben.

## Softwaretests 
Die Software wurde größtenteils auf unseren Smartphones getestet aber auch auf Emulatoren, sowie auf einem Tablet. Zudem haben wir auch Unit-Tests für den `UserManager` und den `ValidierungsManager` geschrieben, welche hautpsächlich testen, ob die Funktionen richtig auf die Responses des Server reagieren. Dies wurde mithilfe von `mockito` umgesetzt, um die HTTP-Requests zu mocken.

## Bedienungsanleiten
siehe `readme.md`

## Quellen
Noah
